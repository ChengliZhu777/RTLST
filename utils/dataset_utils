import os
import string

from PIL import ExifTags


def get_chars(latin_type, eos='EOS', padding='PAD', unknown='UNK'):
    if latin_type == 'lowercase':
        chars = list(string.digits + string.ascii_lowercase)
    elif latin_type == 'all-case':
        chars = list(string.digits + string.ascii_letters)
    elif latin_type == 'all-cases-symbols':
        chars = list(string.printable[:-6])
    else:
        raise KeyError('latin-type must be as follow: \n'
                       '1) lowercase'
                       '2) all-cases'
                       '3) all-cases-symbols')

    chars.extend([eos, padding, unknown])
    char2id, id2char = dict(zip(chars, range(len(chars)))), dict(zip(range(len(chars)), chars))
    return chars, char2id, id2char


def image2label_paths(image_paths, dataset_format='RTLSTD'):
    if dataset_format in ['RTLSTD', 'ICDAR2015']:
        sa, sb = os.sep + 'images' + os.sep, os.sep + 'labels' + os.sep
    else:
        raise KeyError(f'Error: unsupported dataset format {dataset_format}.')

    return ['txt'.join(path.replace(sa, sb, 1).rsplit(path.split('.')[-1], 1)) for path in image_paths]


def get_exif_size(image_size, image_exif):
    image_exif = {ExifTags.TAGS[k]: v for k, v in image_exif if k in ExifTags.TAGS}
    orientation = image_exif.get('Orientation', None)
    if orientation == 6 or orientation == 8:
        return image_size[1], image_size[0]

    return image_size


def get_hash(files):
    return sum(os.path.getsize(file) for file in files if os.path.isfile(file))


def random_scale(image, image_size, scale_range, aspect_range, short_size=768, patch_size=128):

    scale = (np.random.choice(scale_range) * short_size) / min(image_size)
    aspect = math.sqrt(np.random.choice(aspect_range))
    w_scale, h_scale = scale / aspect, scale * aspect

    return scale_image(image, image_size, (w_scale, h_scale), patch_size)


def scale_image(image, image_size, scale_size, patch_size=128):
    width, height = math.ceil(int(image_size[0] * scale_size[0] + 0.5) / patch_size) * patch_size, \
                    math.ceil(int(image_size[1] * scale_size[1] + 0.5) / patch_size) * patch_size

    return cv2.resize(image, dsize=(width, height))
